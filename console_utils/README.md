![](https://i.imgur.com/D7CrsPv.jpg)
![](https://i.imgur.com/4y1fFnO.jpg)
![](https://i.imgur.com/Jw5Gf4D.jpg)
![](https://i.imgur.com/8iG6TC7.jpg)
![](https://i.imgur.com/iOx8220.jpg)
![](https://i.imgur.com/rJhlEFb.jpg)
![](https://i.imgur.com/2MrBJjD.jpg)
![](https://i.imgur.com/wTlm9ce.jpg)
![](https://i.imgur.com/JdZYMG0.jpg)
![](https://i.imgur.com/8l0YaHh.jpg)
![](https://i.imgur.com/E8HdocG.jpg)











grep - поиск в образца в файлеhttps://wiki.merionet.ru/servernye-resheniya/39/rukovodstvo-po-komande-grep-v-linux/

grep [опции] значение [ФАЙЛ]

-i — поиск не будет чувствителен к регистру. То есть, если вы хотите найти слово «автомобиль», написанные как «АВТОМОБИЛЬ» слова тоже будут найдены.
-c — покажет только количество строк, содержащих поисковый запрос
-r — включает рекурсивный поиск в текущем каталоге
-n — выведет номера строк, содержащих поисковый запрос
-v — обратный поиск, выводит только строки, в которых нет указанного поискового запроса
Поиск слова в текстовом файле
grep запрос файл
grep command grep
grep -i запрос файл
Количество найденных слов по целевому запросу
grep -c запрос файл
Поиск по нескольким ключевым словам
grep запрос1 файл | grep запрос2 файл
Поиск слова в нескольких файлах
grep -l слово_которое_ищете ./*








curl
$ curl опции ссылка
Теперь рассмотрим основные опции:
-# - отображать простой прогресс-бар во время загрузки;
-0 - использовать протокол http 1.0;
-1 - использовать протокол шифрования tlsv1;
-2 - использовать sslv2;
-3 - использовать sslv3;
-4 - использовать ipv4;
-6 - использовать ipv6;
-A - указать свой USER_AGENT;
-b - сохранить Cookie в файл;
-c - отправить Cookie на сервер из файла;
-C - продолжить загрузку файла с места разрыва или указанного смещения;
-m - максимальное время ожидания ответа от сервера;
-d - отправить данные методом POST;
-D - сохранить заголовки, возвращенные сервером в файл;
-e - задать поле Referer-uri, указывает с какого сайта пришел пользователь;
-E - использовать внешний сертификат SSL;
-f - не выводить сообщения об ошибках;
-F - отправить данные в виде формы;
-G - если эта опция включена, то все данные, указанные в опции -d будут передаваться методом GET;
-H - передать заголовки на сервер;
-I - получать только HTTP заголовок, а все содержимое страницы игнорировать;
-j - прочитать и отправить cookie из файла;
-J - удалить заголовок из запроса;
-L - принимать и обрабатывать перенаправления;
-s - максимальное количество перенаправлений с помощью Location;
-o - выводить контент страницы в файл;
-O - сохранять контент в файл с именем страницы или файла на сервере;
-p - использовать прокси;
--proto - указать протокол, который нужно использовать;
-R -  сохранять время последнего изменения удаленного файла;
-s - выводить минимум информации об ошибках;
-S - выводить сообщения об ошибках;
-T - загрузить файл на сервер;
-v - максимально подробный вывод;
-y - минимальная скорость загрузки;
-Y - максимальная скорость загрузки;
-z - скачать файл, только если он был модифицирован позже указанного времени;
-V - вывести версию.
ЗАГРУЗКА ФАЙЛОВ
Самая частая задача - это загрузка файлов linux. Скачать файл очень просто. Для этого достаточно передать утилите в параметрах имя файла или html страницы:
 curl https://raw.githubusercontent.com/curl/curl/master/README.md
 curl -o readme.txt https://raw.githubusercontent.com/curl/curl/master/README.md

 curl -O https://raw.githubusercontent.com/curl/curl/master/README.md

 curl -# -C - -O https://cdn.kernel.org/pub/linux/kernel/v4.x/testing/linux-4.11-rc7.tar.xz

 curl -O https://raw.githubusercontent.com/curl/curl/master/README.md -O https://raw.githubusercontent.com/curl/curl/master/README
 curl -z 21-Dec-17 https://raw.githubusercontent.com/curl/curl/master/README.md -O https://raw.githubusercontent.com/curl/curl/master/README

ОГРАНИЧЕНИЕ СКОРОСТИ

 curl --limit-rate 50K -O https://cdn.kernel.org/pub/linux/kernel/v4.x/testing/linux-4.11-rc7.tar.xz

 curl -Y 100 -O https://raw.githubusercontent.com/curl/curl/master/README.md

ПЕРЕДАЧА ФАЙЛОВ

 curl -T login.txt ftp://speedtest.tele2.net/upload/

 curl -T ~/login.txt http://posttestserver.com/post.php

ОТПРАВКА ДАННЫХ POST

 curl -d "field1=val&fileld2=val1"http://posttestserver.com/post.php

 curl -F "password=@pass;type=text/plain" http://posttestserver.com/post.php

ПЕРЕДАЧА И ПРИЕМ КУКИ

 curl -c cookie.txt http://posttestserver.com/post.php

 curl -b cookie.txt http://posttestserver.com/post.php

ПЕРЕДАЧА И АНАЛИЗ ЗАГОЛОВКОВ

 curl -I https://losst.ru

 curl -I --header 'If-Modified-Since: Mon, 26 Dec 2016 18:13:12 GMT' https://losst.ru

АУТЕНТИФИКАЦИЯ CURL
 curl -u ftpuser:ftppass -T - ftp://ftp.testserver.com/myfile_1.txt
ИСПОЛЬЗОВАНИЕ ПРОКСИ
 curl -x proxysever.test.com:3128 http://google.co.in



lsof

Список всех открытых файлов в Linux
lsof /dev/null
Чтобы вывести список файлов, открытых для конкретного пользователя, выполните следующую команду: замените merionet вашим именем пользователя.
$ lsof -u merionet
Еще одно важное использование lsof - выяснение процесса прослушивания определенного порта. Например, определите процесс, прослушивающий порт 80, с помощью следующей команды.
$ sudo lsof -i TCP:80
FD означает файловый дескриптор. Некоторые из общих значений для FD:
cwd – Текущий рабочий каталог
txt – текстовые файлы
mem – файл с отображенной памятью
mmap – Устройство с отображенной памятью
NUMBER – фактический дескриптор файла. У этого также есть информация о том, в каком разрешении файла это открыто.
TYPE это не просто. Он определяет тип файла. Вот некоторые примеры:
REG – обычный файл
DIR – Справочник
CHR – специальный файл символов
FIFO – первый на первом
 
lsof -i
 
 
Вы также можете указать тип сетевого подключения. Например, чтобы вывести список всех открытых портов TCP, вы можете использовать:
lsof -i tcp
 
Чтобы узнать, какой процесс использует определенный порт, вы можете указать номер порта:
lsof -i :<port_number>
 
Бонусный совет: использование оператора отрицания с lsof
Вы можете использовать оператор отрицания, чтобы исключить пользователя или процесс при использовании команды lsof.
Например, вы хотите перечислить все файлы, открытые пользователем, отличным от root, используйте его следующим образом:
lsof -u ^root



1. Перечислите все процессы, которые открыли файл
Это просто Вам просто нужно указать путь к файлу.
lsof <path_to_file>
 
2. Список всех файлов, открытых пользователем
Это удобно в многопользовательской среде. Вы можете перечислить все файлы, открытые определенным пользователем, следующим образом:
lsof -u <user_name>
 
Вы также можете указать более одного пользователя, как это:
lsof -u user1, user2
 
или вот так:
lsof -u user1 -u user2
 
3. Список всех открытых файлов в каталоге
Если вам интересно, какие из файлов были открыты в определенном каталоге, вы можете использовать команду lsof с опцией + D.
lsof +D <path_to_directory>
 
Поиск рекурсивный. Таким образом, он перечислит все открытые файлы в указанном каталоге и все его подкаталоги.
4. Перечислите все открытые файлы процессом
В этом случае вам нужно знать идентификатор процесса (pid). Если вы знаете идентификатор процесса, вы можете использовать опцию -p команды lsof, чтобы найти файлы, открытые им.
lsof -p <pid>
 
Вы также можете указать несколько идентификаторов процессов.
lsof -p pid1, pid2, pid3
 
5. Список всех файлов, открытых командой
Это особенно полезно при отладке. Предположим, вы хотите увидеть, какие файлы используются демоном http, вам просто нужно указать имя команды (httpd в нашем примере).
lsof -c <command>
 
6. Найти открытый пользователем и командой или процессом
Вы можете комбинировать параметры, такие как пользователь и команда, и процесс, используя вариант -, Думайте об этом как об операторе AND. Это дает вам дополнительный фильтр при попытке сузить область поиска.
lsof -a -u user_name -c command_name


wget
1. Загрузка одного файла

Если всё, что нужно — это загрузка одного файла, нам подойдёт следующая конструкция:

$ wget https://downloads.sourceforge.net/project/nagios/nagios-4.x/nagios-4.3.1/nagios-4.3.1.tar.gz?r=&ts=1489637334&use_mirror=excellmedia

После ввода такой команды начнётся скачивание Nagios Core. В ходе этого процесса можно будет видеть данные о загрузке, например — сведения о том, какой объём данных уже загружен, текущую скорость, и то, сколько времени осталось до конца загрузки.

2. Загрузка файла и сохранение его с новым именем

Если мы хотим сохранить загруженный файл под именем, отличающимся от его исходного имени, нам пригодится команда wget с параметром -O:

$ wget -O nagios_latest https://downloads.sourceforge.net/project/nagios/nagios-4.x/nagios-4.3.1/nagios-4.3.1.tar.gz?r=&ts=1489637334&use_mirror=excellmedia

При таком подходе загруженный файл будет сохранён под именем nagios_latest.

3. Ограничение скорости загрузки файлов

При необходимости скорость загрузки файлов с помощью wget можно ограничить. В результате эта операция не будет занимать весь доступный канал передачи данных и не повлияет на другие процессы, связанные с сетью. Сделать это можно, используя параметр --limit-rate и указав ограничение скорости, выраженное в байтах (в виде обычного числа), килобайтах (добавив после числа K) или мегабайтах (M) в секунду:

$ wget ––limit-rate=500K https://downloads.sourceforge.net/project/nagios/nagios-4.x/nagios-4.3.1/nagios-4.3.1.tar.gz?r=&ts=1489637334&use_mirror=excellmedia

Здесь задано ограничение скорости загрузки, равное 500 Кб/с.

4. Завершение прерванной загрузки

Если в ходе загрузки файлов эта операция была прервана, можно возобновить загрузку с помощью параметра -c команды wget:

$ wget –c https://downloads.sourceforge.net/project/nagios/nagios-4.x/nagios-4.3.1/nagios-4.3.1.tar.gz?r=&ts=1489637334&use_mirror=excellmedia

Если этот параметр не использовать, то загрузка недокачанного файла начнётся сначала.

5. Фоновая загрузка файла

Если вы загружаете файл огромного размера и хотите выполнять эту операцию в фоне, сделать это можно, используя параметр -b:

$ wget –b https://downloads.sourceforge.net/project/nagios/nagios-4.x/nagios-4.3.1/nagios-4.3.1.tar.gz?r=&ts=1489637334&use_mirror=excellmedia

6. Загрузка нескольких файлов

Если имеется список URL файлов, которые надо загрузить, но вам не хочется вручную запускать загрузки этих файлов, можно использовать параметр -I. Однако, перед тем, как начинать загрузку, нужно создать файл, содержащий все адреса. Например, сделать это можно такой командой:

$ vi url.txt

В этот файл нужно поместить адреса — по одному в каждой строке. Далее, осталось лишь запустить wget, передав этой утилите только что созданный файл со списком загрузок:

$ wget –I url.txt

Выполнение этой команды приведёт к поочерёдной загрузке всех файлов из списка.

7. Увеличение общего числа попыток загрузки файла

Для того, чтобы настроить число повторных попыток загрузки файла, можно использовать параметр --tries:

wget ––tries=100 https://downloads.sourceforge.net/project/nagios/nagios-4.x/nagios-4.3.1/nagios-4.3.1.tar.gz?r=&ts=1489637334&use_mirror=excellmedia

8. Загрузка файлов с FTP-сервера

Команда загрузки файла с анонимного FTP-сервера с помощью wget выглядит так:

$ wget FTP-URL

Если для доступа к файлу требуются имя пользователя и пароль, то команда примет такой вид:

$ wget –-ftp-user=dan ––ftp-password=********* FTP-URL

9. Создание локальной копии веб-сайта

Если нужно загрузить содержимое целого веб-сайта, сделать это можно, воспользовавшись параметром --mirror:

$ wget --mirror -p --convert-links -P /home/dan xyz.com

Обратите внимание на дополнительные параметры командной строки:

-p: производится загрузка всех файлов, необходимых для корректного отображения HTML-страниц.
--convert-links: ссылки в документах будут преобразованы для целей локального просмотра сайта.
-P /home/dan: материалы будут сохранены в папку /home/dan.

10. Загрузка с сайта только файлов определённого типа

Для того, чтобы загрузить с сайта только файлы определённого типа, можно воспользоваться параметрами -r -A:

$ wget -r -A.txt Website_url

11. Пропуск файлов определённого типа

Если вы хотите скопировать целый веб-сайт, но при этом вам не нужны файлы определённого типа, отключить их загрузку можно с помощью параметра --reject:

$ wget --reject=png Website_url

12. Загрузка с использованием собственного .log-файла

Для того, чтобы загрузить файл и использовать при этом собственный .log-файл, воспользуйтесь параметром -o и укажите имя файла журнала:

$ wget -o wgetfile.log https://downloads.sourceforge.net/project/nagios/nagios-4.x/nagios-4.3.1/nagios-4.3.1.tar.gz?r=&ts=1489637334&use_mirror=excellmedia



tail
$ tail опции файл
По умолчанию утилита выводит десять последних строк из файла, но ее поведение можно настроить с помощью опций:
-c - выводить указанное количество байт с конца файла;
-f - обновлять информацию по мере появления новых строк в файле;
-n - выводить указанное количество строк из конца файла;
--pid - используется с опцией -f, позволяет завершить работу утилиты, когда завершится указанный процесс;
-q - не выводить имена файлов;
--retry - повторять попытки открыть файл, если он недоступен;
-v - выводить подробную информацию о файле;
 
ИСПОЛЬЗОВАНИЕ TAIL
Теперь, когда вы знаете основные опции, рассмотрим приемы работы с утилитой. Самый простой пример - выводим последние десять строк файла:
 tail /var/log/syslog
 
 
Если вам недостаточно 10 строк и нужно намного больше, то вы можете увеличить этот параметр с помощью опции -n:
 tail -n 100 /var/log/syslog
 
Когда вы хотите отслеживать появление новых строк в файле, добавьте опцию -f:
 tail -f /var/log/syslog
 
Вы можете открыть несколько файлов одновременно, просто перечислив их в параметрах:
 tail /var/log/syslog /var/log/Xorg.0.log
 
С помощью опции -s вы можете задать частоту обновления файла. По умолчанию данные обновляются раз в секунду, но вы можете настроить, например, обновление раз в пять секунд:
 tail -f -s 5 /var/log/syslog
 
При открытии нескольких файлов будет выводиться имя файла перед участком кода. Если вы хотите убрать этот заголовок, добавьте опцию -q:
 tail -q var/log/syslog /var/log/Xorg.0.log
 
Если вас интересует не число строк, а именно число байт, то вы можете их указать с помощью опции -c:
 tail -c 500 /var/log/syslog
 
Для удобства, вы можете выбирать не все строки, а отфильтровать интересующие вас:
 tail -f /var/log/syslog | grep err
 
 
Особенно, это полезно при анализе логов веб сервера или поиске ошибок в реальном времени. Если файл не открывается, вы можете использовать опцию retry чтобы повторять попытки:
 tail -f --retry /var/log/syslog | grep err
Как я говорил в начале статьи, по умолчанию опция -f или --follow отслеживает файл по его имени, но вы можете включить режим отслеживания по дескриптору файла, тогда даже если имя измениться, вы будете получать всю информацию:
 tail --follow=descriptor /var/log/syslog | grep err
Как Пользоваться Командой Tail?
Помните, что сначала вам нужно будет использовать терминал или PuTTY, чтобы подключения к вашему VPS-серверу по SSH. Вот руководство с подробным описанием этого процесса.
По умолчанию tail выводит последние 10 строк файла в операционной системе Linux и затем заканчивает выполнение.
Чтобы просмотреть эти строки, введите следующую команду:
tail имя_файла
Или так:
tail путь_к_файлу
В выводе будут отображены последние 10 строк файла.
Как Ограничить Количество Выводимых Строк?
Tale предоставляет возможность посмотреть то количество срок, которое вам нужно. Для этого просто используйте опцию –n.
Самый простой способ выполнить это действие:
Tail –n* путь_к_файлу
Вместо * укажите необходимое количество строк.
Например, если мы хотим просмотреть две строки из файла, мы будем использовать следующую команду:
tail -n2 devisers.txt
2 — количество строк, devisers.txt — имя файла.
Как Посмотреть Последнее Количество Байтов Данных?
Чтобы просмотреть последнее или N-нное количество байтов очень большого файла, используйте параметр -c.
tail –c* путь_к_файлу
Замените * на количество байтов, которое необходимо вывести.
Как Отслеживать Изменения в Файле?
Чтобы проверить файл на наличие новой информации, используйте команду tail вместе с опцией -f. Эта команда будет полезна при просмотре последних десяти строк файла. Опция обычно используется для отслеживания файлов логов в реальном времени. Для нашего файла devisers.txt команда будет выглядеть так:
tail -f devisers.txt
Новые версии команд tail также позволяют пользователю просматривать несколько файлов или папок. После изменения исходного файла заголовок покажет, в какую строку кто-то внёс изменения.
Как Использовать Команду Tail с Другими Командами Linux?
Команды tail могут использоваться вместе с другими функциями командной строки Linux. Например:
Команда Tail с -r (Обратный Порядок)
Например, мы хотим просмотреть вывод команды tail в обратном порядке.
tail –n* имя_файла | sort -r
Первая часть команды такая же, как и раньше, затем мы разделяем её с помощью | для обозначения последующего действия — sort -r, которое, как следует из названия, сортирует вывод в обратном порядке.
Использование Команды Tail с ls (Самый Старый Файл или Папка)
С помощью следующего примера мы просмотрим семь файлов или папок, которые были изменены наиболее давно.
Чтобы сделать это, пропишем ls перед командой tail. Вот, как это будет выглядеть:
ls -l | tail -n8
Как уже упоминалось раньше, в tail части команды -n8 вы можете указать любое число.
 
ГлавнаяКомандыКоманда head linux
КОМАНДА HEAD LINUX
Команды Обновлено:  13 апреля, 2020  2  ellado 
Команда head выводит начальные строки (по умолчанию — 10)  из одного или нескольких документов. Также она может показывать данные, которые передает на вывод другая утилита.
Сегодня мы расскажем как работает эта команда для Linux и покажем, как используются на практике наиболее популярные опции head.
Содержание статьи
КОМАНДА HEAD В LINUX
Синтаксис у команды head следующий:
$ head опции файл
Здесь:
Опции — это параметр, который позволяет настраивать работу команды таким образом, чтобы результат соответствовал конкретным потребностям пользователя.
Файл — это имя документа (или имена документов, если их несколько). Если это значение не задано либо вместо него стоит знак «-», команда будет брать данные из стандартного вывода.
Чаще всего к команде head применяются такие опции:
-c (--bytes) — позволяет задавать количество текста не в строках, а в байтах. При записи в виде --bytes=[-]NUM выводит на экран все содержимое файла, кроме NUM байт, расположенных в конце документа.
-n (--lines) — показывает заданное количество строк вместо 10, которые выводятся по умолчанию. Если записать эту опцию в виде --lines=[-]NUM, будет показан весь текст кроме последних NUM строк.
-q (--quiet, --silent) — выводит только текст, не добавляя к нему название файла.
-v (--verbose) — перед текстом выводит название файла.
-z (--zero-terminated) — символы перехода на новую строку заменяет символами завершения строк.
head file-name.txt
 
Если нужно единовременно получить вывод с нескольких файлов, с этим тоже не возникнет проблем. Достаточно перечислить названия, разделяя их пробелом:
head file-name1.txt file-name2.txt
 
Разумеется, файлов может быть и три, и четыре, и больше. Чтобы не возникало путаницы, их содержимое автоматически разделяется пустой строкой, а перед текстом выводится название документа.
Чтобы название файла выводилось даже в том случае, когда команде задан только один документ, следует воспользоваться опцией -v:
head -v file-name.txt
 
Если десяти строк, по умолчанию выводимых командой, окажется слишком мало или слишком много, ничто не мешает изменить их количество вручную. Для этой цели служит опция -n:
head -n file-name.txt
 
Не будем забывать об еще одном интересном свойстве этой опции. Она позволяет вывести то количество строк, которое останется после «отсечения» лишнего текста. Для этого нужно использовать не сокращенную (однобуквенную), а полную запись опции:
head --lines=[-]NUM
Во время работы в терминале квадратные скобки не используются, знак минуса идет сразу же после знака равно. Вместо NUM следует указать число. Вот как выглядит запись команды и ее результат на скриншоте.
 
Следует заметить, что строки «отсекаются», начиная с последней.
До этого момента мы (и команда head вместе с нами) считали количество текста построчно. Но это не обязательное условие — с таким же успехом единицей измерения может быть байт. Достаточно сообщить команде о новом правиле работы с помощью опции -с, заодно указав и количество байт, которое нужно вывести на экран (NUM):
head -c NUM file-name.txt
 
Как и в случае с опцией --lines, можно «отсечь» ненужный объем текста, используя полную форму опции -с — --bytes. Запись команды проводится по тому же принципу и лишние байты тоже отсчитываются, начиная с конца документа:
head --bytes=[-]NUM
 
При записи байт можно использовать буквенные суффиксы:
b — умножает число на 512.
kB — на 1000.
k — на 1024.
MB — на 1 000 000.
M — на 1 048 576.
Кстати, команду head можно использовать не только самостоятельно, но и в сочетании с другими командами. Например, такая запись хеширует рандомно выбранную переменную среды, выводит первые 32 байта из указанного файла и отображает случайную строку из 24 символов:
echo $RANDOM | sha512sum | head -c 24 file-name.txt; echo
синтаксис:
head [OPTION]... [FILE]...
 
И следующее, как man page описывает команду head:
Печатает первые 10 строк каждого ФАЙЛА на стандартный вывод. С более чем один ФАЙЛ, перед каждым заголовком идет имя файла.
Следующие примеры должны дать вам лучшее представление о том, как работает инструмент:
Q1. Как напечатать первые 10 строк файла на терминале (стандартный вывод)?
Это довольно легко, используя head – на самом деле, это поведение по умолчанию для инструмента.
head [file-name]
 
На следующем примере показана команда в действии:
root@destroyer:/etc/nginx# head nginx.conf                                                                                                                     
user www-data;                                                                                                                                                
worker_processes 3;                                                                                                                                           
 
error_log  /var/log/nginx/error.log notice;                                                                                                                   
                                                                                                                                                              
worker_rlimit_nofile 65535;                                                                                                                                   
 
pid        /var/run/nginx.pid;                                                                                                                                
 
events {
 
Q2. Как настроить вывод определенного количество линий с помощью команды head?
В то время как 10 строк является по умолчанию, которое команда head печатает, вы можете изменить это число в соответствии с вашими требованиями. опция -n командной строки позволяет сделать это.
head -n [N] [File-name]
 
Например, если вы хотите напечатать только первые 5 строк, вы можете передать в этот инструмент следующим образом:
head -n 5 file1
 
root@destroyer:/etc/nginx# head -n 5 nginx.conf                                                                                                                
user www-data;                                                                                                                                                
worker_processes 3;                                                                                                                                           
                                                                                                                                                              
error_log  /var/log/nginx/error.log notice;
 
Q3. Как ограничить вывод определенного количества байтов?
Не только количество строк, вы можете также ограничить вывода команды head на определенное число байтов. Это может быть сделано с помощью параметра -c командной строки.
head -c [N] [File-name]
 
Например, если вы хотите, чтобы отображались только первые 25 байт, то вот как вы можете выполнить его:
head -c 25 file1
 
root@destroyer:/etc/nginx# head -c 25 nginx.conf                                                                                                               
user www-data;
 
Таким образом, вы можете увидеть, что инструмент отображает только первые 25 байт в выводе.
Пожалуйста, обратите внимание, что [N] ” может иметь суффикс множитель: б 512, кбайт 1000, K 1024, MB 1000 * 1000, M 1024 * 1024, GB 1000 * 1000 * 1000, G 1024 * 1024 * 1024, и так далее для Т, Р, Е, Z, Y «.
Q4. Как напечатать и имя файла на выводе?
Если по какой-то причине, вы хотите, чтобы команда head также напечатала имя файла на выводе, вы можете сделать это с помощью опции -v командной строки.
head -v [file-name]
 
Вот пример:
root@destroyer:/etc/nginx# head -c 25 nginx.conf                                                                                                               
user www-data;                                                                                                                                                
worker_proroot@destroyer:/etc/nginx# head -v nginx.conf                                                                                                        
==> nginx.conf <==                                                                                                                                            
user www-data;                                                                                                                                                
worker_processes 3;                                                                                                                                           
                                                                                                                                                              
error_log  /var/log/nginx/error.log notice;                                                                                                                   
                                                                                                                                                              
worker_rlimit_nofile 65535;                                                                                                                                   
 
pid        /var/run/nginx.pid;                                                                                                                                
 
events {
 
Как вы можете видеть, имя файла «файл 1» был указан на выводе.
Q5. Как указать NUL разделитель в линии, вместо новой строки?
По умолчанию, вывод команды head ограничен новой строки. Но есть также возможность использования NUL в качестве разделителя. Опция -z или  –zero-terminated позволяет сделать это.
head -z [file-name]
 
 
Примеры использования
Вывод первых десяти строк текстового файла
Для вывода первых десяти строк текстового файла достаточно использовать утилиту head без каких-либо параметров:
$ head 1342.txt
PRIDE AND PREJUDICE
By Jane Austen
Chapter 1
 
It is a truth universally acknowledged, that a single man in possession
Очевидно, что утилита вывела первые 10 строк файла.
Вывод заданного количества строк текстового файла
Для вывода заданного количества строк текстового файла следует использовать параметр -n:
$ head -n 3 1342.txt
PRIDE AND PREJUDICE
By Jane Austen
Теперь утилита вывела лишь необходимые три строки.
Вывод заданного количества байтов файла
Для того, чтобы вывести заданное количество байтов вместо заданного количества строк, достаточно использовать параметр -c таким же образом, как ранее использованный параметр -n:
$ head -c 23 1342.txt
PRIDE AND PREJUDICE
В первые 23 байта вошла первая строка текстового файла с символом перехода на новую строку.
Обработка вывода других утилит
Для того, чтобы вывести лишь первые строки вывода другой утилиты, достаточно использовать простой конвейер командной оболочки и не указывать имен файлов:
$ cat 1342.txt | head -n 3
PRIDE AND PREJUDICE
By Jane Austen
Утилита cat читает все содержимое текстового файла, а утилита head выполняет роль фильтра, выводя лишь три первые строки этого содержимого.
Вывод первых строк нескольких файлов
$ head -n 3 1342.txt 74.txt
==> 1342.txt <==
PRIDE AND PREJUDICE
By Jane Austen
==> 74.txt <==
THE ADVENTURES OF TOM SAWYER
By Mark Twain
Теперь утилита добавляет в вывод имена текстовых файлов для того, чтобы не возникало путаницы; в остальном она работает точно так же.
less
Практические примеры команды less в Linux
Давайте посмотрим, как использовать команду less в Linux с некоторыми практическими примерами.
Лучше работать с большим файлом, чтобы понять использование команды less. Вместо того, чтобы вручную создавать огромный текстовый файл, я бы посоветовал скопировать существующий файл из /etc/services в ваш домашний каталог или где бы вы ни занимались этими командами.
/etc/services – это большой файл с сотнями строк и один раз сделав копию, вы можете использовать его для своей практики.
1. Просмотрите текстовый файл с командой less
Как показано в синтаксисе, вы можете использовать команду less для просмотра файла следующим образом:
less [option]<filename>
 
Результат будет примерно таким:
Просмотр текстового файла с командой less
Примечание
Если вы просмотрите короткий текстовый файл с командой less, вы увидите пустые пустые строки вверху. Не паникуйте. В вашем файле нет лишних строк. Просто их less.
2. Выход из less
Если вы не привыкли к командам less, вы можете попытаться найти выход из les. Поверьте мне, это совсем не сложно. Просто нажмите «q» в любой точке, чтобы выйти из less.
3. Перемещение в less
Результат less делится на несколько страниц. Вы увидите только текст, который заполняется до экрана терминала.
Читать  Может ли иметь таблица пространство WASTED/FRAGMENTED без удаления данных (DELETE) в MySQL?
Вы можете использовать клавиши со стрелками вверх и вниз для перемещения по строкам. Если вы хотите переместить страницу за страницей, используйте клавишу пробела, чтобы перейти на следующую страницу и клавишу «b», чтобы вернуться к предыдущей странице.
Если вы хотите перейти к началу файла, используйте ключ «g». Если вы хотите перейти в конец файла, нажмите клавишу «G».
Горячие клавиши:
Стрелка вверх – перемещение на одну строку вверх
Стрелка вниз – перемещение на одну строку вниз
Пробел или PgDn – перемещение на одну страницу вниз
b или PgUp – переместить на одну страницу вверх
g – переместить в начало файла
G – переместить в конец файла
ng – перейти на n-ю строку
4. Отобразить номера строк с командой less
Если вы хотите видеть номера строк в выводе команды less, вы можете использовать опцию N следующим образом:
less -N <filename>
 
Вы увидите такой вывод:
Отображение номеров строк с less
5. Поиск текста с less
Если у вас большой текстовый файл, лучше искать конкретный фрагмент текста, а не читать его по строкам, чтобы найти его вручную.
Чтобы найти слово или фразу или шаблон регулярного выражения, нажмите / и введите все, что вы хотите найти.
/pattern
 
Как вы можете видеть, найденный текст подсвечивается.

Поиск текста в less
Если есть несколько совпадений, вы можете перейти к следующему согласованному тексту, нажав клавишу «n». Вы можете вернуться к предыдущему совпадению с помощью клавиши «N».
«/Pattern» выполняет прямой поиск. Вы можете использовать ‘?Pattern’ для выполнения обратного поиска. Лично я предпочитаю делать прямой поиск, а затем нажимать n или N, чтобы перебирать все совпадения. Не нужно беспокоиться о поиске вперед или назад.
По умолчанию поиск в less случае зависит от регистра. Чтобы игнорировать случай, вы можете использовать less с опцией -I
less -I <filename>
 
Если вы забыли использовать эту опцию, не волнуйтесь. Вы также можете нажать комбинацию клавиш «-I», прежде чем выполнять поиск внутри less.
Совет
Если вы используете &pattern, будут отображаться только строки, соответствующие шаблону.
6. Маркировка интересных точек
Пока вы прокручиваете большой текстовый файл, и вы находите что-то интересное, но вам также нужно продолжить проверку файла, как бы вы помнили этот интересный момент? Ответ – это маркировка.
less позволяет добавлять метки, типы флагов в любую строку. Вы можете добавить отметку, нажав клавишу «m», а затем букву.
ma
 
Когда вы захотите вернуться к этому знаку, просто нажмите ‘, за которым следует эта буква:
'a
 
Вы не ограничены одной меткой. Вы можете добавить несколько меток less. Просто используйте другую букву для каждой отмеченной позиции.
Читать  Как очистить файл журнала в Linux
7. Мониторинг файлов в режиме реального времени с командой less
Вероятно, вы уже знаете, что вы можете использовать команду tail для мониторинга файлов журнала в реальном времени.
Вы также можете сделать то же самое с командой less. Вы можете видеть, что новые строки добавляются в файл в реальном времени с помощью опции + F.
less +F <filename>
 
Он отобразит последнюю страницу файла и дождитесь добавления новых данных. Обратите внимание, что вы не можете выполнять регулярное перемещение вверх и вниз, назад и вперед в этом режиме.
Чтобы выйти из режима реального времени, нажмите Ctrl + C. При этом вы вернетесь к нормальному виду команды less и можете нормально завершить работу с файлом.
8. Просмотр нескольких файлов с командой less.
Я буду честен с вами. Это не мой любимый пример с командой, но вы можете это сделать полностью.
Чтобы открыть несколько файлов с командой less, просто введите имена файлов один за другим:
less <filename1> <filename2> <filename3>
 
Вы увидите, что в нем указано имя файла вместе с его позицию в списке файлов.

Просмотр нескольких файлов с командой less
Вы можете просмотреть другие файлы в списке, используя следующие ключи:
: n – просмотр следующего файла в списке
: p – просмотр предыдущего файла в списке
9. Использование команды less с pipes
Команда less может использоваться при сопряжении с другими командами с использованием pipes. Это особенно полезно, когда вы знаете, что вывод определенной команды будет огромным.
Например, вывод команды dmesg обычно находится в тысячах строк. Если вы не хотите, чтобы он заполнял ваш экран, но вы также не сможете анализировать результат. Наберите его с командой less, и у вас будет более дружеский способ чтения вывода.
dmesg | less
 
Бонусный совет: отредактируйте файл с командой less в Linux
Нет, вы не сможите этого сделать. Вы не можете редактировать файл командой less.
Одним из самых больших преимуществ команды less является то, что она предоставляет представление «только для чтения».
Если вы не можете редактировать текст с командой less, то почему я добавил это как пример с командой less? Потому что, когда вам кажется, что вам нужно отредактировать просматриваемый файл, просто нажмите клавишу «v» .
Он откроет файл в текстовом редакторе командной строки по умолчанию вашей системы Linux. Для системы на основе Ubuntu ее следует открыть в редакторе Nano.
СИНТАКСИС И ОПЦИИ LESS
Запись команды less в терминале выглядит так:
команда опции файл
Наиболее популярные опции:
-a, --search-skip-screen — не осуществлять поиск в тексте, который в данный момент отображен на экране;
-bn, --buffers=n — задать размер буфера памяти;
-c, --clear-screen — листать текст, полностью стирая содержимое экрана (построчная прокрутка работать не будет);
-Dxcolor, --color=xcolor — задать цвет отображаемого текста;
-E, --QUIT-AT-EOF — выйти, когда утилита достигнет конца файла;
-e, --quit-at-eof — выйти, когда утилита второй раз достигнет конца файла;
-F, --quit-if-one-screen — выйти, если содержимое файла помещается на одном экране;
-f, --force — открыть специальный файл;
-hn, --max-back-scroll=n — задать максимальное количество строк для прокрутки назад;
-yn, --max-forw-scroll=n — задать максимальное количество строк для прокрутки вперёд;
-i, --ignore-case — игнорировать регистр;
-I, --IGNORE-CASE — игнорировать регистр, даже если паттерн для поиска содержит заглавные буквы;
-jn, --jump-target=n — указать, в какой строке должна быть выведена искомая информация;
-J, --status-column — пометить строки, соответствующие результатам поиска;
-n, --line-numbers — не выводить номера строк;
-N, --LINE-NUMBERS — вывести номера строк;
-s, --squeeze-blank-lines — заменить множество идущих подряд пустых строк одной пустой строкой;
-w, --hilite-unread — выделить первую строку нового фрагмента текста.
Во время просмотра текста утилитой можно управлять при помощи внутренних команд, набирая их на клавиатуре компьютера. Наиболее часто используемые из них:
h, H — справка;
Space, Ctrl+V, f, Ctrl+F — прокрутить текст на один экран вперёд;
Enter, Return, Ctrl+N, e, Ctrl+E, j, Ctrl+J — прокрутить текст на n строк вперед, по умолчанию n=1;
y, Ctrl+Y, Ctrl+P, k, Ctrl+K — прокрутить текст на n строк назад, по умолчанию n=1;
Ctrl+→ — прокрутить текст по горизонтали в конец строки;
Ctrl+← — прокрутить текст по горизонтали в начало строки;
:d — удалить текущий файл из списка файлов;
Ctrl+G, :f — вывести основную информацию о файле;
q, Q, :q, :Q, ZZ — выход.






find
nd [папка] [параметры] критерий шаблон [действие]

Папка - каталог в котором будем искать

Параметры - дополнительные параметры, например, глубина поиска, и т д

Критерий - по какому критерию будем искать: имя, дата создания, права, владелец и т д.

Шаблон - непосредственно значение по которому будем отбирать файлы.

ОСНОВНЫЕ ПАРАМЕТРЫ КОМАНДЫ FIND
Я не буду перечислять здесь все параметры, рассмотрим только самые полезные.

-P никогда не открывать символические ссылки
-L - получает информацию о файлах по символическим ссылкам. Важно для дальнейшей обработки, чтобы обрабатывалась не ссылка, а сам файл.
-maxdepth - максимальная глубина поиска по подкаталогам, для поиска только в текущем каталоге установите 1.
-depth - искать сначала в текущем каталоге, а потом в подкаталогах
-mount искать файлы только в этой файловой системе.
-version - показать версию утилиты find
-print - выводить полные имена файлов
-type f - искать только файлы
-type d - поиск папки в Linux
КРИТЕРИИ
Критериев у команды find в Linux очень много, и мы опять же рассмотрим только основные.

-name - поиск файлов по имени
-perm - поиск файлов в Linux по режиму доступа
-user - поиск файлов по владельцу
-group - поиск по группе
-mtime - поиск по времени модификации файла
-atime - поиск файлов по дате последнего чтения
-nogroup - поиск файлов, не принадлежащих ни одной группе
-nouser - поиск файлов без владельцев
-newer - найти файлы новее чем указанный
-size - поиск файлов в Linux по их размеру
ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ
А теперь давайте рассмотрим примеры find, чтобы вы лучше поняли, как использовать эту утилиту.

1. ПОИСК ВСЕХ ФАЙЛОВ
Показать все файлы в текущей директории:

 find

 find .

 find . -print

2. ПОИСК ФАЙЛОВ В ОПРЕДЕЛЕННОЙ ПАПКЕ
Показать все файлы в указанной директории:

 find ./test

Искать файлы по имени в текущей папке:

 find . -name "*.jpg"

Не учитывать регистр при поиске по имени:

 find . -iname "test*"

3. ОГРАНИЧЕНИЕ ГЛУБИНЫ ПОИСКА
Поиска файлов по имени в Linux только в этой папке:

 find . -maxdepth 1 -name "*.php"

4. ИНВЕРТИРОВАНИЕ ШАБЛОНА
Найти файлы, которые не соответствуют шаблону:

 find . -not -name "test*"

5. НЕСКОЛЬКО КРИТЕРИЕВ
Поиск командой find в Linux по нескольким критериям, с оператором исключения:

 find . -name "test" -not -name "*.php"

Найдет все файлы, начинающиеся на test, но без расширения php. А теперь рассмотрим оператор ИЛИ:

 find -name "*.html" -o -name "*.php"

6. НЕСКОЛЬКО КАТАЛОГОВ
Искать в двух каталогах одновременно:

 find ./test ./test2 -type f -name "*.c"

7. ПОИСК СКРЫТЫХ ФАЙЛОВ
Найти скрытые файлы:

 find ~ -type f -name ".*"

8. ПОИСК ПО РАЗРЕШЕНИЯМ
Найти файлы с определенной маской прав, например, 0664:

 find . type f -perm 0664

Найти файлы с установленным флагом suid/guid:

 find / -perm 2644

Или так:

 find / -maxdepth 2 -perm /u=s

Поиск файлов только для чтения:

 find /etc -maxdepth 1 -perm /u=r

Найти только исполняемые файлы:

 find /bin -maxdepth 2 -perm /a=x

9. ПОИСК ФАЙЛОВ ПО ГРУППАХ И ПОЛЬЗОВАТЕЛЯХ
Найти все файлы, принадлежащие пользователю:

 find . -user sergiy

Поиск файлов в Linux принадлежащих группе:

 find /var/www -group developer

10. ПОИСК ПО ДАТЕ МОДИФИКАЦИИ
Поиск файлов по дате в Linux осуществляется с помощью параметра mtime. Найти все файлы модифицированные 50 дней назад:

 find / -mtime 50

Поиск файлов в Linux открытых N дней назад:

 find / -atime 50

Найти все файлы, модифицированные между 50 и 100 дней назад:

 find / -mtime +50 –mtime -100

Найти файлы измененные в течении часа:

 find . -cmin 60

11. ПОИСК ФАЙЛОВ ПО РАЗМЕРУ
Найти все файлы размером 50 мегабайт:

 find / -size 50M

От пятидесяти до ста мегабайт:

 find / -size +50M -size -100M

Найти самые маленькие файлы:

 find . -type f -exec ls -s {} \; | sort -n -r | head -5

Самые большие:

 find . -type f -exec ls -s {} \; | sort -n | head -5

12. ПОИСК ПУСТЫХ ФАЙЛОВ И ПАПОК
 find /tmp -type f -empty

$ find ~/ -type d -empty

13. ДЕЙСТВИЯ С НАЙДЕННЫМИ ФАЙЛАМИ
Для выполнения произвольных команд для найденных файлов используется опция -exec. Например, выполнить ls для получения подробной информации о каждом файле:

 find . -exec ls -ld {} \;

Удалить все текстовые файлы в tmp

 find /tmp -type f -name "*.txt" -exec rm -f {} \;

Удалить все файлы больше 100 мегабайт:

 find /home/bob/dir -type f -name *.log -size +10M -exec rm -f {} \;


ssh
БАЗОВЫЙ СИНТАКСИС
Синтаксис команды выглядит следующим образом:
$ ssh [опции] имя пользователя@сервер [команда]
Важно заметить что ssh может работать по двум версиям протокола. Версии 1 и 2. Понятное дело, что версия 2 лучше и поддерживает больше типов шифрования и аутентификации. Больше в этой статье об отличиях протоколов мы говорить не будем и я буду подразумевать что вы используете версию 2.
ОПЦИИ КОМАНДЫ SSH
Теперь давайте рассмотрим самые основные опции команды ssh:
f - перевести ssh в фоновый режим;
g - разрешить удаленным машинам обращаться к локальным портам;
l - имя пользователя в системе;
n - перенаправить стандартный вывод в /dev/null;
p - порт ssh на удаленной машине;
q - не показывать сообщения об ошибках;
v - режим отладки;
x - отключить перенаправление X11;
X - включить перенаправление Х11;
C - включить сжатие.
Это далеко не все опции утилиты, остальные выходят за рамки данной статьи. Многие настройки работы ssh можно изменять через конфигурационный файл ~/.ssh/config но здесь мы это тоже подробно рассматривать не будем.
НАСТРОЙКА СЕРВЕРА SSH
Настройки сервера SSH находятся в файле /etc/ssh/sshd_config. Многие из них мы тоже трогать не будем. Рассмотрим только самые интересные. Сначала откройте файл /etc/ssh/sshd.conf
ПОРТ SSH
По умолчанию ssh работает на порту 22. Но такое поведение небезопасно, поскольку злоумышленник знает этот порт и может попробовать выполнить Bruteforce атаку для перебора пароля. Порт задается строчкой:
Port 22
Поменяйте значение порта на нужное.
ПРОТОКОЛ SSH
По умолчанию сервер ssh может работать по двум версиям протокола, для совместимости. Чтобы использовать только протокол версии два раскомментируйте строчку:
 Protocol 2
И приведите ее к такому виду:
Protocol 2
РУТ ДОСТУП
По умолчанию Root доступ по ssh разрешен, но такое поведение очень небезопасно, поэтому раскомментируйте строчку:
PermitRootLogin no
ДОСТУП ТОЛЬКО ОПРЕДЕЛЕННОГО ПОЛЬЗОВАТЕЛЯ К SSH
Мы можем разрешить доступ к ssh только для определенного пользователя или группы. Для этого  добавьте строчки:
AllowUsers User1, User2, User3
AllowGroups Group1, Group2, Group3
Здесь User1 и Group1 - пользователь и группа к которым нужно разрешить доступ.
ВЫПОЛНЕНИЕ X11 ПРИЛОЖЕНИЙ
Не все знают но есть возможность использовать ssh для запуска полноценных X11 приложений. Об этом мы поговорим ниже, но чтобы все заработало необходимо разрешить эту возможность на стороне сервера, добавьте такую строчку:
X11Forwarding yes
Основные опции рассмотрели, перед тем как переходить дальше, не забудьте перезагрузить ssh сервер чтобы сохранить изменения:
 service sshd restart
ИСПОЛЬЗОВАНИЕ SSH
Основная цель этой статьи - показать интересные и полезные способы использования ssh, о которых, возможно, вы не знали. Переходим к самому вкусному - возможности ssh.
ПОДКЛЮЧЕНИЕ К СЕРВЕРУ
Чтобы просто подключиться к серверу по SSH используйте такую команду:
 ssh user@host
ВЫПОЛНИТЬ КОМАНДУ
Мы привыкли подключаться к удаленному серверу, а уже потом выполнять нужные команды, но на самом деле утилита ssh позволяет сразу выполнить нужную команду без открытия терминала удаленной машины. Например:
 ssh user@host ls
Выполнит команду ls на удаленном сервере и вернет ее вывод в текущий терминал.
ВЫПОЛНИТЬ ЛОКАЛЬНЫЙ СКРИПТ
Выполним интерпретатор bash на удаленном сервере и передадим ему наш локальный скрипт с помощью перенаправления ввода Bash:
 ssh user@host 'bash -s' < script.sh
БЕКАП НА УДАЛЕННЫЙ СЕРВЕР И ВОССТАНОВЛЕНИЕ
Мы можем сохранять бекэп диска сразу на удаленном сервере с помощью ssh. Перенаправим вывод dd с помощью оператора перенаправления |, затем сохраним его на той стороне в файл:
 sudo dd if=/dev/sda | ssh user@host 'dd of=sda.img'
Теперь чтобы восстановить состояние диска из сделанной копии выполните:
 ssh user@host 'dd if=sda.img' | dd of=/dev/sda
Здесь и выше /dev/sda имя файла вашего жесткого диска.
АУТЕНТИФИКАЦИЯ БЕЗ ПАРОЛЯ
Использование ssh пароля для входа на сервер не только неудобно но и небезопасно, потому что этот пароль в любой момент может быть подобран. Самый надежный и часто используемый способ аутентификации - с помощью пары ключей RSA. Секретный ключ хранится на компьютере, а публичный используется на сервере для удостоверения пользователя.
Настроить такое поведение очень легко. Сначала создайте ключ командой:
 ssh-keygen -t rsa
Во время создания ключа нужно будет ответить на несколько вопросов, расположение оставляйте по умолчанию, если хотите подключаться без пароля - поле Passphare тоже оставьте пустым.
Затем отправляем ключ на сервер:
 ssh-copy-id -i ~/.ssh/id_rsa.pub user@host
Вот и все. Теперь при попытке подключится к этому серверу пароль запрашиваться не будет, а стазу произойдет подключение. Смотрите подробнее создание открытого ключа для ssh.
ВЗЯТЬ ПАРОЛЬ ИЗ ЛОКАЛЬНОГО ФАЙЛА
Напомню, что хранить пароли в обычных текстовых файлах небезопасно, но если хотите, то да - возможно. Для этого используется оператор перенаправления ввода Bash:
 ssh user@host < local_file.txt
 ИЗМЕНИТЬ ПРИВЕТСТВИЕ SSH
При входе по ssh может выводиться приветствие, изменить его очень легко. За это отвечает файл /etc/issue. Просто откройте этот файл и введите нужный текст:
 vi /etc/issue
Welcome!
СМОТРИМ НЕУДАЧНЫЕ ПОПЫТКИ ВХОДА SSH
Хотите посмотреть были ли попытки неудачного доступа по ssh к вашему серверу и с каких IP адресов? Запросто, все запросы логируются в файл /var/log/secure, отфильтруем только нужные данные командой:
 cat /var/log/secure | grep "Failed password for"
ПЕРЕДАЧА ФАЙЛОВ ПО SSH
Кроме выполнения команд, можно копировать файлы по ssh. Для этого используется утилита scp. Просто укажите файл, который нужно передать, удаленный сервер и папку на сервере, вот:
$ scp /адрес/локального/файла пользователь@хост:адерс/папки
Например:
 scp ~/test.txt user@host:documents
Кроме утилиты scp, передача файлов ssh может быть выполнена более хитрым способом. Прочитаем файл и с помощью cat, передадим, а там сохраним поток в файл:
 cat localfile | ssh user@host "cat > remotefile"
Или так:
 ssh user@host "cat > remotefile" < localfile
Пойдем еще дальше, вы можете сжимать файлы перед передачей с помощью tar, а потом их сразу же на лету распаковывать:
 tar czf - /home/user/file | ssh user@host tar -xvzf -C /home/remoteuser/
Такое копирование файлов ssh позволяет отправлять сразу целые папки.
ЗАПУСК ГРАФИЧЕСКИХ ПРИЛОЖЕНИЙ ПО SSH
Если вам нужно запустить то или иное графическое приложение на удаленной машине необязательно для этого использовать VNC, вы можете обойтись возможностями ssh. Программа будет выполняться на стороне сервера, а вам будет лишь транслироваться окно, чтобы вы могли сделать все что нужно. Причем все данные шифруются. Чтобы эта функция работала, нужно включить ее поддержку на стороне сервера.
Затем просто выполняем команду запуска графического приложения на удаленном сервере вот таким образом:
 ssh -XC user@remotehost "eclipse"
Как вы уже видели опция X разрешает перенаправление X11 на стороне клиента, а С - сжатие данных.
ЗАВЕРШЕНИЕ СЕССИИ SSH
Если вы использовали SSH с нестабильным интернетом, когда соединение время от времени рвется, то вам уже, наверное, надоело закрывать терминал, потому что иначе, на первый взгляд, сеанс никак не прекратить. Когда соединение с удаленным сервером разорвано вы не можете ввести никакую команду и сочетания клавиш Ctrl+C, Ctrl+Z, Ctrl+D не работают. И не будут работать поскольку клиент пытается отправить эти команды на сервер. Но есть решение - Escape последовательности. Чтобы активировать их поддержку добавьте строку:
EscapeChar ~
В файл /etc/ssh/ssh_config. Теперь, чтобы разорвать SSH соединение достаточно нажать Enter и набрать:
~.
Другие управляющие символы можно узнать нажав:
~?
ТУННЕЛИ SSH
С помощью SSH туннелей вы можете пробросить порт с удалённого сервера на локальную машину. Это очень полезно, в первую очередь, для разработчиков. Для того чтобы пробросить порт с удалённой машины локальной используйте опцию -L и такой синтаксис:
$ ssh -L локальный_порт:удаленный_адрес:удаленный_порт пользователь@сервер
Например, сделаем удалённую базу данных доступной локально на порту 5555. Для этого выполните подставив свои значения:
$ ssh -N -L 5555:127.0.0.1:3306 root@losst-1

Опция -N сообщает, что команду на удалённой машине выполнять не нужно. Локальный порт - 5555, поскольку сервер баз данных слушает на локальном интерфейсе удалённой машины, то и здесь надо указывать адрес 127.0.0.1. А порт MySQL по умолчанию 3306. Если же вы хотите чтобы локальный сервис был доступен на удалённой машине, то следует использовать опцию -R:
$ ssh -N -R 5555:127.0.0.1:3306 root@losst-1
Теперь локальная база данных на порту 3306 будет доступна на удалённом сервере при обращении к порту 5555.




Базовый синтаксис
Чтобы подключиться к удаленной системе с помощью SSH, мы будем использовать команду ssh. В самом базовом виде команда имеет следующую форму:
ssh remote_host


 
Copy
remote_host в этом примере является IP-адресом или доменным именем узла, к которому вы пытаетесь подключиться.
Эта команда предполагает, что ваше имя пользователя на удаленной системе совпадает с именем пользователя в локальной системе.
Если ваше локальное имя пользователя отличается от имени пользователя в удаленной системе, вы можете задать его, используя следующий синтаксис:
ssh remote_username@remote_host


 
Copy
После подключения к серверу вам, возможно, потребуется подтвердить вашу личность с помощью пароля. Позже мы рассмотрим, как сгенерировать ключи, которые можно использовать вместо паролей.
Чтобы завершить сеанс ssh и вернуться в сеанс локальной оболочки, введите следующую команду:
exit


 
Copy
Как работает SSH?
SSH выполняет подключение клиентской программы к серверу ssh с именем sshd.
В предыдущем разделе команда ssh использовалась для вызова клиентской программы. Сервер ssh уже запущен на удаленном хосте remote_host, который мы указали.
На вашем сервере должен быть запущен сервер sshd. Если это не так, вам может потребоваться подключение к серверу через веб-консоль или локальную последовательную консоль.
Процесс запуска сервера ssh зависит от дистрибутива Linux, который вы используете.
В Ubuntu вы можете запустить сервер ssh с помощью следующей команды:
sudo systemctl start ssh


 
Copy
Эта команда должна запускать сервер sshd, после чего вы сможете выполнять удаленный вход.
Настройка SSH
При изменении конфигурации SSH вы меняете настройки сервера sshd.
В Ubuntu основной файл конфигурации sshd находится в каталоге /etc/ssh/sshd_config.
Выполните резервное копирование текущей версии этого файла перед началом редактирования:
sudo cp /etc/ssh/sshd_config{,.bak}


 
Copy
Откройте файл в текстовом редакторе:
sudo nano /etc/ssh/sshd_config


 
Copy
Скорее всего, вы захотите оставить большинство опций в этом файле без изменений. Однако существует несколько настроек, на которые вам стоит обратить особое внимание:
/etc/ssh/sshd_config
Port 22
 
Copy
Объявление порта указывает, подключения к какому порту будет отслеживать сервер sshd. По умолчанию используется порт 22. Вам, скорее всего, не придется изменять данную настройку, если только у вас нет конкретных причин для иного решения. Если вы решите изменить порт, позже мы покажем, как подключиться к новому порту.
/etc/ssh/sshd_config
HostKey /etc/ssh/ssh_host_rsa_key
HostKey /etc/ssh/ssh_host_dsa_key
HostKey /etc/ssh/ssh_host_ecdsa_key
 
Copy
В объявлениях ключей хоста указывается, где нужно искать глобальные ключи хоста. Мы обсудим, что такое ключ хоста, позже.
/etc/ssh/sshd_config
SyslogFacility AUTH
LogLevel INFO
 
Copy
Эти две строки указывают на уровень логирования, который необходимо использовать.
Если вы сталкиваетесь с проблемами при работе с SSH, увеличение объема логируемых данных может быть хорошим решением, которое поможет понять, в чем заключается проблема.
/etc/ssh/sshd_config
LoginGraceTime 120
PermitRootLogin yes
StrictModes yes
 
Copy
Эти параметры определяют некоторые данные для входа в систему.
Опция LoginGraceTime определяет количество секунд, в течение которых следует сохранять подключение при отсутствии успешных попыток входа в систему.
Возможно, вам может быть полезным задать для этого параметра чуть большее количество времени, чем то, которое вам обычно требуется для входа.
PermitRootLogin определяет, разрешен ли вход с помощью пользователя с правами root.
В большинстве случаев необходимо изменить значение на no, если вы создали учетную запись пользователя, которая имеет доступ к высокому уровню привилегий (через su или sudo) и может использоваться для входа в систему через ssh.
strictModes — это защитник, который будет препятствовать попыткам входа, если файлы аутентификации доступны для чтения всем.
Он позволяет предотвратить попытки входа в систему, когда файлы конфигурации не находятся в безопасном состоянии.
/etc/ssh/sshd_config
X11Forwarding yes
X11DisplayOffset 10
 
Copy
Эти параметры используются для настройки такой возможности, как X11 Forwarding. X11 Forwarding позволяет просматривать графический пользовательский интерфейс (GUI) удаленной системы на локальной системе.
Эта функция должна быть активирована на сервере и передана клиенту SSH во время подключения с помощью опции -X.
После внесения изменений сохраните и закройте файл, введя CTRL+X, Y, а затем нажмите ENTER.
Если вы внесли изменения в какие-либо настройки в файле /etc/ssh/sshd_config, необходимо перезапустить ваш сервер sshd, чтобы изменения вступили в силу:
sudo systemctl reload ssh


 
Copy
Вы должны тщательно протестировать ваши изменения, чтобы убедиться, что все работает так, как вы ожидаете.
Вы можете использовать несколько активных сеансов во время внесения изменений. Это позволит вам вернуться к первоначальной конфигурации, если это потребуется.
Выполнение входа через SSH с использованием ключей
Хотя возможность входа в удаленную систему с помощью паролей может быть полезна, гораздо лучшей идеей будет настройка аутентификации с помощью ключей.
Как работает аутентификация с помощью ключей?
Аутентификация с помощью ключей реализуется путем создания пары ключей: приватного ключа и публичного ключа.
Приватный ключ располагается на клиентском компьютере, этот ключ защищен и хранится в секрете.
Публичный ключ может передаваться любому лицу или размещаться на сервере, доступ к которому вы хотите получить.
При попытке подключения с использованием пары ключей сервер будет использовать публичный ключ для создания сообщения для клиентского компьютера, которое может быть прочитано только с помощью приватного ключа.
Затем клиентский компьютер отправляет соответствующий ответ обратно серверу, после чего сервер будет знать, что клиент не является поддельным.
Весь этот процесс выполняется в автоматическом режиме после того, как вы настроите ключи.
Создание ключей SSH
Ключи SSH необходимо генерировать на компьютере, откуда вы хотите войти в систему. Как правило, это ваш локальный компьютер.
Введите следующую команду в командной строке:
ssh-keygen -t rsa


 
Copy
Нажмите ENTER, чтобы принять используемые по умолчанию значения. Ваши ключи будут сгенерированы в файлах ~/.ssh/id_rsa.pub и ~/.ssh/id_rsa.
Перейдите в каталог .ssh с помощью следующей команды:
cd ~/.ssh


 
Copy
Просмотрите данные о разрешениях для файлов:
ls -l


 
Copy
Output
-rw-r--r-- 1 demo demo  807 Sep  9 22:15 authorized_keys
-rw------- 1 demo demo 1679 Sep  9 23:13 id_rsa
-rw-r--r-- 1 demo demo  396 Sep  9 23:13 id_rsa.pub

Как вы можете видеть, файл id_rsa доступен для чтения и записи только владельцу. Именно такие разрешения позволяют сохранить его в секрете.
В то же время файл id_rsa.pub может использоваться совместно и имеет соответствующие разрешения для данной деятельности.
Как передать ваш публичный ключ на сервер
Если в настоящее время вы используете доступ к серверу с помощью пароля, вы можете скопировать ваш публичный ключ на сервер, воспользовавшись данной командой:
ssh-copy-id remote_host


 
Copy
В результате будет создан сеанс SSH. Когда вы введете пароль, ваш публичный ключ будет скопирован в файл авторизованных ключей сервера, что позволит не использовать пароль при входе в следующий раз.
Опции для клиентской стороны
Существует ряд опциональных флагов, которые вы можете использовать при подключении через SSH.
Некоторые из них могут быть необходимы при наличии определенных настроек конфигурации sshd на удаленном хосте.
Например, если вы изменили номер порта в конфигурации sshd, вам потребуется указать этот порт на клиентской стороне с помощью следующей команды:
ssh -p port_number remote_host


 
Copy
Если вы хотите выполнить отдельную команду на удаленной системе, вы можете указать ее после имени хоста следующим образом:
ssh remote_host command_to_run


 
Copy
В результате будет установлено подключение к удаленному компьютеру, а после успешной аутентификации команда будет выполнена.
Как уже отмечалось ранее, если функция X11 forwarding активирована на обоих компьютерах, вы можете получить доступ к данному функционалу, воспользовавшись следующей командой:
ssh -X remote_host


 
Copy
При наличии соответствующих инструментов на вашем компьютере программы GUI, которые вы используете на удаленной системе, теперь будут открываться в отдельном окне на локальной системе.
Отключение аутентификации по паролю
Если вы создали ключи SSH, вы можете повысить уровень безопасности вашего сервера, отключив аутентификацию только по паролю. Помимо консоли единственным способом входа на ваш сервер будет использование приватного ключа, который используется в паре с публичным ключом, установленным на сервере.
Предупреждение: перед выполнением этих действий необходимо убедиться, что публичный ключ установлен на сервере. В противном случае вы заблокируете доступ к серверу!
Откройте файл конфигурации sshd, воспользовавшись пользователем root или пользователем с привилегиями sudo:
sudo nano /etc/ssh/sshd_config


 
Copy
Найдите строку Password Authentication и раскомментируйте ее, удалив символ # в начале строки. Теперь вы можете указать значение no:
/etc/ssh/sshd_config
PasswordAuthentication no
 
Copy
Вы должны также изменить значения двух других настроек (если вы не вносили изменения в этот файл ранее) — PubkeyAuthentication и ChallengeResponseAuthentication. Значения устанавливаются по умолчанию и выглядят следующим образом:
/etc/ssh/sshd_config
PubkeyAuthentication yes
ChallengeResponseAuthentication no
 
Copy
После внесения изменений сохраните и закройте файл.
Теперь нужно перезапустить демон SSH:
sudo systemctl reload ssh


 
Copy
Теперь аутентификация по паролю должна быть отключена, а ваш сервер должен быть доступен только с помощью аутентификации по ключу SSH.
kill
Синтаксис
kill опции PID
 
PID — это PID (числовой идентификатор) процесса или несколько PID процессов, если требуется послать сигнал сразу нескольким процессам.
По умолчанию команда kill шлет сигнал KILL (он также называется SIGKILL и имеет числовое значение 9).
Опции
-Сигнал или -s Сигнал или --signal Сигнал
Задает сигнал, который будет послан процессу. Сигнал может задаваться числом или названием.
-l или -l Сигнал или --list Сигнал
Вывести список всех сигналов.
Если задано значение Сигнал, то вывод зависит от того, чему равно заданное значение Сигнал:
числовой номер сигнала — в таком случае будет выведено название сигнала;
название сигнала — в таком случае будет выведено числовое значение сигнала.
-L или --table
Вывести список сигналов в табличном виде. Выводится числовое значение и название каждого сигнала.
Примеры использования команды kill
Определить PID процесса
Так как команда kill принимает на вход PID (идентификатор) процесса, то необходимо сначала узнать PID процесса, которому требуется отправить сигнал. Чтобы это сделать, можно использовать команду ps (вместо firefox укажите название процесса):
ps -ef | grep firefox

Вывести список сигналов
Выведем список всех доступных сигналов:
kill -L
В результате получим список сигналов и их числовые значения:
$ kill -L
1 HUP 2 INT 3 QUIT 4 ILL 5 TRAP 6 ABRT 7 BUS
8 FPE 9 KILL 10 USR1 11 SEGV 12 USR2 13 PIPE 14 ALRM
15 TERM 16 STKFLT 17 CHLD 18 CONT 19 STOP 20 TSTP 21 TTIN
22 TTOU 23 URG 24 XCPU 25 XFSZ 26 VTALRM 27 PROF 28 WINCH
29 POLL 30 PWR 31 SYS

Отправка сигнала SIGTERM
Пошлем сигнал SIGTERM процессу с PID 3012:
kill 3012
Отправка сигнала KILL (завершение процесса)
Пошлем сигнал KILL процессу с PID 3121, чтобы принудительно завершить процесс:
kill -KILL 3121
Или можно использовать числовое значение сигнала:
kill -9 3121
Отправка сигнала нескольким процессам
Выполним отправку сигнала KILL сразу нескольким процессам. Для этого необходимо перечислить их идентификаторы:
kill -9 2903 2977 3012
sudo htop
 
Столбцы:

PID - идентификатор процесса.

USER - владелец процесса.

PRI - текуший приоритет (влияет на процессорное время, отводимое процессу, значение по умолчанию - 20; чем меньше приоритет, тем больше времени отводится процессу, следовательно он выполняется быстрее).

NI - величина изменения приоритета относительно значения PRI (клавиши F7, F8).

VIRT - общий объем виртуальной памяти, используемой процессом. Включает в себя: область кода (CODE), данные (DATA), разделяемые библиотеки (SHARED) и страницы, перемещенные в swap-область памяти. Если приложение потребовало от ядра выделить ему 100Мб памяти, а использует всего 5 Мб, данный столбец всё равно будет показывать цифру 100.
(CODE - объем памяти, содержащий исполняемый код процесса.
DATA - объем памяти, занятой данными, используемыми процессом в ходе выполнения.
SWAP - объем памяти, используемой процессом, но перемещенной в swap-область.)

RES - количество резидентной (не перемещаемой в swap) памяти в килобайтах. Если приложение потребовало от ядра выделить ему 100Мб памяти, а использует всего 5 Мб, то данный столбец покажет 5. Но здесь есть два ньюанса:
а) RES не показывает сколько данных было перемещено в swap,
б) часть RES-памяти может быть разделяемой.

SHR - количество разделяемой (shared) памяти программы в килобайтах, т.е. памяти, которая может быть использована другими приложениями.

S - состояние процесса:
S — так называемое состояние сна;
R — состояние выполнения;
D — состояние ожидания.

CPU% - использование процессора в процентном отношении.

MEM% - использование процессом памяти в процентном отношении.

TIME+ - время работы процесса.

Command - указывает на команду, которой был запущен процесс.

Через настройки (F2) можно добавить еще некоторые полезные параметры:

IO RATE - Операции ввода\вывода. Чтение + запись. Если нужно отдельно на чтение и на запись, то можно добавить:

IO READ RATE и IO WRITE RATE.

Также на экран выводятся следующие параметры:

Load average - отражает число блокирующих процессов в очереди на исполнение в определенный временной интервал, а именно 1 минута, 5 минут и 15 минут, соответственно. Блокирующий процесс — это процесс, который ожидает ресурсов для продолжения работы.

Uptime - время работы системы.

Управление:

F1 - справка;
F2 - настройки;
F3 - поиск процесса;
F4 - сортировка списка процессов (от большего к меньшему или от меньшего к большему);
F5 - устанавливает древовидное отображение (корни - родительские процессы, а листья - дочерние) и наоборот;
F6 - открывает панель с выбором параметра сортировки процессов;
F7 - увеличить приоритет выполнения текущего процесса;
F8 - уменьшить приоритет выполнения текущего процесса;
F9 - убить процесс;
F10 - выйти из программы.


/
